// Package golfram provides a go interface with the wolfram alpha api
package golfram

import (
	"encoding/xml"
	"errors"
	//"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"strings"
)

const (
	libraryVersion    = "0.2"
	wolframDefaultURL = "http://api.wolframalpha.com/v2/query"
)

// Client that connects to the wolfram api
type Client struct {
	client     *http.Client
	AppID      string
	Results    []*Queryresult
	WolframURL string
}

// Pod generated by wolfram for the query
// Contains subpods, and title of the pod
type Pod struct {
	Error      string    `xml:"error,attr"`
	Id         string    `xml:"id,attr"`
	Title      string    `xml:"title,attr"`
	Numsubpods int       `xml:"numsubpods,attr"`
	Subpod     []*Subpod `xml:"subpod"`
}

type Source struct {
	Url  string `xml:"url,attr"`
	Text string `xml:"text,attr"`
}

type Assumption struct {
	Type     string   `xml:"type,attr"`
	Word     string   `xml:"word,attr"`
	Template string   `xml:"template,attr"`
	Values   []*Value `xml:"value"`
}

type Value struct {
	Name  string `xml:"name,attr"`
	Desc  string `xml:"desc,attr"`
	Input string `xml:"input,attr"`
}

// Subpod in pod
// Img: Image inside of subpod(if exists)
// Title: Title of subpod
// Plaintext: Plaintext response for subpod(if exists)
type Subpod struct {
	Title     string `xml:"title,attr"`
	Plaintext string `xml:"plaintext"`
	Img       Img    `xml:"img"`
}

// Image in subpod
// Src: Url of image
type Img struct {
	Src    string `xml:"src,attr"`
	Width  string `xml:"width,attr"`
	Height string `xml:"height,attr"`
}

// Result of query
// Input: query string
// Success
// Error
// Datatypes: types of pods returned
// Pod[]: array of pods returned
// Podtitles[]: array of titles of pods(not to be used externally instead use result.GetPodByTitle(title)
type Queryresult struct {
	Input       string
	Success     string `xml:"success,attr"`
	Error       string `xml:"error,attr"`
	Numpods     int    `xml:"numpods,attr"`
	Datatypes   string `xml:"datatypes,attr"`
	Pod         []*Pod `xml:"pod"`
	Podtitles   []string
	Assumptions []*Assumption `xml:"assumptions>assumption"`
	Sources     []*Source     `xml:"sources>source"`
}

// Constructs a new client given an api key
// Returns pointer to client
func NewClient(appID string, wolframURL string) *Client {
	httpClient := http.DefaultClient
	c := &Client{client: httpClient, AppID: appID, WolframURL: wolframURL}
	return c
}

// Constructs and sends a query to wolfram api from given string
// Returns pointer to query result and error.
func (c *Client) NewQuery(query string) (*Queryresult, error) {
	urlStr := c.WolframURL + "?input=" + url.QueryEscape(query) + "&appid=" + c.AppID + "&scantimeout=3"
	//fmt.Println(urlStr)
	req, err := http.NewRequest("GET", urlStr, nil)
	if err != nil {
		return nil, err
	}
	resp, _ := c.client.Do(req)

	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	result := &Queryresult{Input: query}

	//fmt.Println(string(body))

	err = xml.Unmarshal(body, &result)
	if err != nil {
		return nil, err
	}

	result = result.GenerateTitles()

	c.Results = append(c.Results, result)

	return result, nil
}

// Not to be used externally called when result is being unmarshalled in NewQuery
// Generates the Podtitles array of the Queryresult
func (r *Queryresult) GenerateTitles() *Queryresult {
	r.Podtitles = make([]string, r.Numpods)
	for index, pod := range r.Pod {
		r.Podtitles[index] = pod.Title
	}
	return r
}

// Returns pod with given title
// Used to find which pod contains plots
func (r *Queryresult) GetPodByTitle(title string) (*Pod, error) {
	for _, pod := range r.Pod {
		if pod.Title == title {
			return pod, nil
		}
	}
	return nil, errors.New("No pod found")
}

func (r *Queryresult) String() string {
	rets := []string{}
	for index, pod := range r.Pod {
		rets = append(rets, "Pod"+string(index)+": "+pod.String())
		rets = append(rets, "\n")
	}
	return strings.Join(rets, "")
}

func (p *Pod) String() string {
	title := ""
	if p.Title != "" {
		title = p.Title + ": "
	}
	rets := []string{title}
	for index, subpod := range p.Subpod {
		if p.Numsubpods > 1 {
			rets = append(rets, "\n\tSubpod"+string(index)+": "+subpod.String())
		} else {
			rets = append(rets, "\n"+subpod.String())
		}
	}
	return strings.Join(rets, "")
}

func (s *Subpod) String() string {
	title := ""
	body := ""
	if s.Title != "" {
		title = s.Title + ": "
	}
	if s.Plaintext != "" {
		body = s.Plaintext
	} else if s.Img.Src != "" {
		body = s.Img.Src
	}
	return title + body
}

// Downloads the plot from the given queryresult at the given index
// Most cases will want to use index of 0(e.q. c.GetPlot(result, 0)
// Returns path to saved plot image and error
func (c *Client) GetPlot(result *Queryresult, index int, filename string) (string, error) {
	return c.GetImage(result, "Plots", index, filename)
}

// Downloads image from subpod at given index of pod in given result with given title
// Most cases will want to use result.GetPlot instead
func (c *Client) GetImage(result *Queryresult, title string, subpod int, filename string) (string, error) {
	pod, err := result.GetPodByTitle(title)
	if err != nil {
		return "No pod found", err
	}
	img := pod.Subpod[subpod].Img
	urlStr := img.Src
	path := filename
	if path == "" {
		path = "imgs/" + strings.Replace(result.Input, " ", "_", -1)
	}
	file, err := os.Create(path)

	req, err := http.NewRequest("GET", urlStr, nil)
	if err != nil {
		return "", err
	}
	resp, _ := c.client.Do(req)

	defer resp.Body.Close()
	_, err = io.Copy(file, resp.Body)

	return path, nil
}
